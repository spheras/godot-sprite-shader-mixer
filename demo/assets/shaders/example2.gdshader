//ATTENTION:
//  THIS IS SHADE AUTOGENERATED BY
//  THE ADDON SPRITE-SHADER-MIXER
//  ANY MANUAL CHANGES WILL BE REMOVED WHEN THE ADDON
//  UPDATES THIS SHADER.
//  ANYWAY, YOU CAN SAVE THE CURRENT VERSION AS A RESOURCE FILE.
//SHADERS:Gold,Teleport,Shadow,
shader_type canvas_item;

	
//GOLD
uniform bool  GOLD_active  = true;
uniform float GOLD_offset: hint_range(0, 100) = 0;
uniform float GOLD_speed : hint_range(0, 10) = 1;
uniform float GOLD_mix : hint_range(0,1)=0;
float gold_calc_luminance(vec3 color)
{
    return dot(color, vec3( 0.299, 0.587, 0.114));
}
float gold_mark_light(vec2 uv, float value)
{
	vec2 co = uv * 5.0;
	float n = sin(value + co.x) + sin(value - co.x) + sin(value + co.y) + sin(value + 2.5 * co.y);
	return fract((5.0 + n) / 5.0);
}
void gold(in vec2 uv, in sampler2D txt, in vec2 spriteSize, in vec2 pixelSize, inout vec4 finalColor)
{
	float value = GOLD_offset + TIME * GOLD_speed;
	vec4 txt_color = texture(txt, uv);
	float luminance = gold_calc_luminance(txt_color.rbg);
	vec3 metal = vec3(luminance);
	metal.r = luminance * pow(1.5 * luminance, 3.0);
	metal.g = luminance * pow(1.5 * luminance, 3.0);
	metal.b = luminance * pow(0.75 * luminance, 3.0);
	
	float n = gold_mark_light(uv, value);
	n += dot(txt_color.rbg, vec3(0.2, 0.4, 0.2));
	n = fract(n);
	
	float a = clamp(abs(n * 6.0 - 2.0), 0.0, 1.0);
	vec4 color = vec4(metal.rgb + (1.0 - a), 1.0);
	color.rgb = color.rgb * 0.5 + dot(color.rgb, vec3 (0.113, 0.455, 0.172)) - vec3(0.0, 0.1, 0.6) + 0.025;
	color.a = txt_color.a;
	finalColor = mix(color, finalColor, GOLD_mix); 
}


//TELEPORT
uniform bool TELEPORT_active = true;
uniform float TELEPORT_progress : hint_range(0.0, 1.0);
uniform float TELEPORT_noise_desnity:hint_range(0.0, 500.0, 0.1) = 60;
uniform float TELEPORT_beam_size : hint_range(0.01, 0.15);
uniform vec4 TELEPORT_color : source_color = vec4(0.0, 1.02, 1.2, 1.0);
vec2 TELEPORT_random(vec2 uv){
    uv = vec2( dot(uv, vec2(127.1,311.7) ),
               dot(uv, vec2(269.5,183.3) ) );
    return -1.0 + 2.0 * fract(sin(uv) * 43758.5453123);
}
float TELEPORT_noise(vec2 uv) {
    vec2 uv_index = floor(uv);
    vec2 uv_fract = fract(uv);

    vec2 blur = smoothstep(0.0, 1.0, uv_fract);

    return mix( mix( dot( TELEPORT_random(uv_index + vec2(0.0,0.0) ), uv_fract - vec2(0.0,0.0) ),
                     dot( TELEPORT_random(uv_index + vec2(1.0,0.0) ), uv_fract - vec2(1.0,0.0) ), blur.x),
                mix( dot( TELEPORT_random(uv_index + vec2(0.0,1.0) ), uv_fract - vec2(0.0,1.0) ),
                     dot( TELEPORT_random(uv_index + vec2(1.0,1.0) ), uv_fract - vec2(1.0,1.0) ), blur.x), blur.y) * 0.5 + 0.5;
}
void teleport(in vec2 uv, in sampler2D txt, vec2 size, vec2 pixelSize, inout vec4 color)
{
	float noise = TELEPORT_noise(uv * TELEPORT_noise_desnity) * uv.y;
	
	float d1 = step(TELEPORT_progress, noise);
	float d2 = step(TELEPORT_progress - TELEPORT_beam_size, noise);
	
	vec3 beam = vec3(d2 - d1) * color.rgb;
	
	color.rgb += beam;
	color.a *= d2;
}
//SHADOW
uniform bool  SHADOW_active  = true;
uniform vec2  SHADOW_deform = vec2(0.0, 0.0);
uniform vec2  SHADOW_offset = vec2(20.0, 20.0);
uniform vec4  SHADOW_modulate : source_color;
uniform float SHADOW_mix : hint_range(0,1) = 0;
void shadow(in vec2 uv, in sampler2D txt, in vec2 size, in vec2 texturePixelSize, inout vec4 color) {
	float sizex = float(textureSize(txt,int(texturePixelSize.x)).x); //comment for GLES2
	float sizey = float(textureSize(txt,int(texturePixelSize.y)).y); //comment for GLES2
	//float sizex = texture_size.x; //uncomment for GLES2
	//float sizey = texture_size.y; //uncomment for GLES2
	uv.y+=SHADOW_offset.y*texturePixelSize.y;
	uv.x+=SHADOW_offset.x*texturePixelSize.x;
	float decalx=((uv.y-texturePixelSize.x*sizex)*SHADOW_deform.x);
	float decaly=((uv.y-texturePixelSize.y*sizey)*SHADOW_deform.y);
	uv.x += decalx;
	uv.y += decaly;
	vec4 shadow = vec4(SHADOW_modulate.rgb, texture(txt, uv).a * SHADOW_modulate.a * 0.5);
	color =mix(mix(shadow, color, color.a), color, SHADOW_mix);
}


void fragment() {
	vec4 color = texture(TEXTURE, UV);
	vec2 size = vec2(textureSize(TEXTURE, 0));
	vec2 uv = UV;
	vec2 screen_uv = SCREEN_UV;

	if(GOLD_active) gold(uv, TEXTURE, size, TEXTURE_PIXEL_SIZE, color);
	if(TELEPORT_active) teleport(uv, TEXTURE, size, TEXTURE_PIXEL_SIZE, color);
	if(SHADOW_active) shadow(uv, TEXTURE, size, TEXTURE_PIXEL_SIZE, color);


	COLOR=color;
}

void vertex() {
	
}
