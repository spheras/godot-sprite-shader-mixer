//ATTENTION:
//  THIS IS SHADE AUTOGENERATED BY
//  THE ADDON SPRITE-SHADER-MIXER
//  ANY MANUAL CHANGES WILL BE REMOVED WHEN THE ADDON
//  UPDATES THIS SHADER.
//  ANYWAY, YOU CAN SAVE THE CURRENT VERSION AS A RESOURCE FILE.
//SHADERS:Matrix,Color Swap,Border Noise,
shader_type canvas_item;

	
//MATRIX
uniform bool      MATRIX_active  = true;
uniform int       MATRIX_direction = 0;
uniform float     MATRIX_velocity : hint_range(0, 4) = 0.5;
uniform float     MATRIX_row : hint_range(1.0, 100.0) = 12.0;
uniform float     MATRIX_column : hint_range(1.0, 100.0) = 12.0;
uniform float     MATRIX_value : hint_range(1, 25) = 20;
uniform sampler2D MATRIX_chars_tex;
uniform float     MATRIX_number_row_char_texture = 3.0;
uniform float     MATRIX_number_column_char_texture = 3.0;
uniform vec4      MATRIX_tint_color : source_color = vec4(0.12, 0.62, 0.92, 1.0);
uniform float     MATRIX_line_thickness : hint_range(0, 20) = 5.0;
uniform float     MATRIX_mix : hint_range(0, 1) = 0;
float matrix_rand1(vec2 co, float random_seed)
{
    return fract(sin(dot(co.xy * random_seed, vec2(12.,85.5))) * 120.01);
}
vec3 matrix_randomColor (int indexColumn) 
{
	float f = float(indexColumn);
	float red = matrix_rand1(vec2(f, 1.0), f) * 0.8;
	float blue = matrix_rand1(vec2(f, 1.0), f + 1.0) * 0.5;
	float green = matrix_rand1(vec2(f, 1.0), f + 2.0);
	return vec3(red, blue, green);
}
float matrix_rand2_with_range(vec2 co, float m, float M, float random_seed)
{
	float r1 = matrix_rand1(co, random_seed);
	return (M - m) * r1 + r1;
}
vec3 matrix_rain(vec2 uv, float _matrix_value, float number_row, float number_column, int di, float time)
{
	float column_size = 1.0 / number_column;
	float row_size = 1.0 / number_row;
	
	float x = uv.x - mod(uv.x, column_size);
	float offset = sin(x * 15.0);
	float speed = cos(x * 3.0) * 0.3 + 0.7;
	
	float y =  uv.y - mod(uv.y, row_size);
	y = (di > 0) ? fract(y + time * speed + offset) : fract(1.0 - y + time * speed + offset);
	float alpha = 1.0 / ((26.0 - _matrix_value) * y);
	
	vec3 color = MATRIX_tint_color.rgb;
	color *= alpha;
	return color;
}
vec2 matrix_randomIndexChar(vec2 char_size, vec2 blockID, float time)
{
	vec2 indexChar = vec2(0, 0);
	float t = time - mod(time, 0.1);
	float r1 = matrix_rand2_with_range(blockID / char_size + t, 1, char_size.x, 1);
	indexChar.x = blockID.x + char_size.x * r1;
	indexChar.y = blockID.y + char_size.y * r1;
	
	indexChar = mod(floor(indexChar), char_size);
	return indexChar;
}
float matrix_text(vec2 uv, float number_row, float number_column, float time)
{
	float column_size = 1.0 / number_column;
	float row_size = 1.0 / number_row;
	vec2 block_size = vec2(column_size, row_size);

	vec2 blockID = floor(uv / block_size);
	vec2 _uv = mod(uv.xy, block_size) / block_size;

	vec2 char_texture_size = vec2(MATRIX_number_row_char_texture, MATRIX_number_column_char_texture);
	vec2 index_char = matrix_randomIndexChar(char_texture_size, blockID, time);
	_uv.y = 1.0 - _uv.y;
	_uv = (index_char + _uv) / char_texture_size;

	return texture(MATRIX_chars_tex, _uv).r;
}
void matrix(in vec2 uv, in sampler2D sampler,in vec2 texSize, vec2 pixelSize, inout vec4 color){
	vec3 rain = matrix_rain(uv, MATRIX_value, floor(MATRIX_row), floor(MATRIX_column), MATRIX_direction, TIME*MATRIX_velocity);
	float text = matrix_text(uv, floor(MATRIX_row), floor(MATRIX_column), TIME*MATRIX_velocity);
	vec3 matrix = text * rain;
	vec4 txt = texture(sampler, uv);
	
	vec2 size = pixelSize * MATRIX_line_thickness;
	float _outline = texture(sampler, uv + vec2(0, -size.y)).a;
	_outline += texture(sampler, uv + vec2(0, -size.y * 2.0)).a;
	_outline += texture(sampler, uv + vec2(0, -size.y * 3.0)).a;
	_outline += texture(sampler, uv + vec2(0, -size.y * 4.0)).a;
	_outline += texture(sampler, uv + vec2(0, -size.y * 5.0)).a;
	_outline += texture(sampler, uv + vec2(size.x, 0)).a;
	_outline += texture(sampler, uv + vec2(-size.x, 0)).a;
	_outline= min(1.0, _outline) - txt.a;
	
	float v = matrix.r + matrix.g + matrix.b;
	if (v > 1.0)
	{
		float have_char = min(1.0, v);
		vec4 outline_matrix = vec4(matrix, 1.0 * text);
		txt = mix(txt, outline_matrix, _outline);
		txt.rgb = mix(txt.rgb, matrix, have_char);
	}
	
	vec4 output_color = txt;
	color = mix(output_color,color,MATRIX_mix);
}

uniform bool  COLORSWAP_active = true;
uniform float COLORSWAP_mix:hint_range(0,1,0.1) = 0;
uniform int   COLORSWAP_max_colors:hint_range(1, 8, 1) = 8;
uniform bool  COLORSWAP_show_stripes = true;
uniform float COLORSWAP_tolerance: hint_range(0.0, 1, 0.1);
uniform vec4  COLORSWAP_input_color1 : source_color;
uniform vec4  COLORSWAP_output_color1 : source_color;
uniform vec4  COLORSWAP_input_color2 : source_color;
uniform vec4  COLORSWAP_output_color2 : source_color;
uniform vec4  COLORSWAP_input_color3 : source_color;
uniform vec4  COLORSWAP_output_color3 : source_color;
uniform vec4  COLORSWAP_input_color4 : source_color;
uniform vec4  COLORSWAP_output_color4 : source_color;
uniform vec4  COLORSWAP_input_color5 : source_color;
uniform vec4  COLORSWAP_output_color5 : source_color;
uniform vec4  COLORSWAP_input_color6 : source_color;
uniform vec4  COLORSWAP_output_color6 : source_color;
uniform vec4  COLORSWAP_input_color7 : source_color;
uniform vec4  COLORSWAP_output_color7 : source_color;
uniform vec4  COLORSWAP_input_color8 : source_color;
uniform vec4  COLORSWAP_output_color8 : source_color;
vec4 COLORSWAP_grayscale(vec4 color){
	float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
	return vec4(gray, gray, gray, color.a);
}
vec4 COLORSWAP_stripe(vec2 uv, vec4 color){
	float w = cos(0.7854) * uv.x + sin(0.7854) * uv.y - 0.05 * TIME;
	if (floor(mod(w * 48.0, 2.0)) < 0.0001) {
		return color;
	}
	else {
		return COLORSWAP_grayscale(color);
	}
}
bool COLORSWAP_isColorSimilar(vec4 color1, vec4 color2){
		return (
			color1.r > (color2.r - COLORSWAP_tolerance) && 
		    color1.r < (color2.r + COLORSWAP_tolerance) && 
			color1.g > (color2.g - COLORSWAP_tolerance) && 
		    color1.g < (color2.g + COLORSWAP_tolerance) &&
			color1.b > (color2.b - COLORSWAP_tolerance) && 
		    color1.b < (color2.b + COLORSWAP_tolerance)
			);
}
void colorswap(in vec2 uv, in sampler2D txt, in vec2 size, in vec2 pixelSize, inout vec4 finalColor){
	vec4[] input_colors = {
		COLORSWAP_input_color1,
		COLORSWAP_input_color2,
		COLORSWAP_input_color3,
		COLORSWAP_input_color4,
		COLORSWAP_input_color5,
		COLORSWAP_input_color6,
		COLORSWAP_input_color7,
		COLORSWAP_input_color8
	};
	
	vec4[] output_colors = {
		COLORSWAP_output_color1,
		COLORSWAP_output_color2,
		COLORSWAP_output_color3,
		COLORSWAP_output_color4,
		COLORSWAP_output_color5,
		COLORSWAP_output_color6,
		COLORSWAP_output_color7,
		COLORSWAP_output_color8
	};
		
	bool is_color = false;
	
	for(int cr = 0; cr < COLORSWAP_max_colors; cr++){
		if (finalColor.a>0. && COLORSWAP_isColorSimilar(finalColor, input_colors[cr])){
			finalColor = mix(output_colors[cr], finalColor, COLORSWAP_mix);
			is_color = true;
			break;
		}
	}

	if (!is_color){
		if (COLORSWAP_show_stripes && !(finalColor.a < 0.001)){
			finalColor = mix(COLORSWAP_stripe(uv, finalColor), finalColor, COLORSWAP_mix);
		}
	}
}

uniform bool BORDERNOISE_active = true;
uniform float BORDERNOISE_max_line_width:hint_range(0.0, 50.0, 0.1) = 10.0;
uniform float BORDERNOISE_min_line_width:hint_range(0.0, 1000.0, 0.1) = 5.0;
uniform float BORDERNOISE_freq:hint_range(0.0, 12.0, 0.1) = 1.0;
uniform float BORDERNOISE_block_size:hint_range(0.0, 100.0, 0.1) = 20.0;
uniform vec4 BORDERNOISE_starting_colour : source_color= vec4(0,0,0,1);
uniform vec4 BORDERNOISE_ending_colour: source_color = vec4(1);
const float BORDERNOISE_pi = 3.1415;
const int BORDERNOISE_ang_res = 16;
const int BORDERNOISE_grad_res = 8;
float BORDERNOISE_hash(vec2 p, float s) {
	return fract(35.1 * sin(dot(vec3(112.3, 459.2, 753.2), vec3(p, s))));
}
float BORDERNOISE_noise(vec2 p, float s) {
	vec2 d = vec2(0, 1)*sin(TIME);
	vec2 b = floor(p)*sin(TIME);
	vec2 f = fract(p);
	return mix(
		mix(BORDERNOISE_hash(b + d.xx, s), BORDERNOISE_hash(b + d.yx, s), f.x),
		mix(BORDERNOISE_hash(b + d.xy, s), BORDERNOISE_hash(b + d.yy, s), f.x), f.y);
}
float BORDERNOISE_getLineWidth(vec2 p, float s) {
	p /= BORDERNOISE_block_size;
	float w = 0.0;
	float intensity = 1.0;
	for (int i = 0; i < 3; i++) {
		w = mix(w, BORDERNOISE_noise(p, s), intensity);
		p /= 2.0;
		intensity /= 2.0;
	}
	
	return mix(BORDERNOISE_max_line_width, BORDERNOISE_min_line_width, w);
}
bool BORDERNOISE_pixelInRange(sampler2D text, vec2 uv, vec2 dist) {
	float alpha = 0.0;
	for (int i = 0; i < BORDERNOISE_ang_res; i++) {
		float angle = 2.0 * BORDERNOISE_pi * float(i) / float(BORDERNOISE_ang_res);
		vec2 disp = dist * vec2(cos(angle), sin(angle));
		if (texture(text, uv + disp).a > 0.0) return true;
	}
	return false;
}
float BORDERNOISE_getClosestDistance(sampler2D text, vec2 uv, vec2 maxDist) {
	if (!BORDERNOISE_pixelInRange(text, uv, maxDist)) return -1.0;
	
	float hi = 1.0; float lo = 0.0;
	
	for (int i = 1; i <= BORDERNOISE_grad_res; i++) {
		float curr = (hi + lo) / 2.0;
		if (BORDERNOISE_pixelInRange(text, uv, curr * maxDist)) {
			hi = curr;
		}
		else {
			lo = curr;
		}
	}
	return hi;
	
}
void borderNoise(in vec2 uv, in sampler2D txt, vec2 size, vec2 pixelSize, inout vec4 color){
	float timeStep = floor(BORDERNOISE_freq * TIME);
	vec2 scaledDist = pixelSize;
	scaledDist *= BORDERNOISE_getLineWidth(uv / pixelSize, timeStep);
	float w = BORDERNOISE_getClosestDistance(txt, uv, scaledDist);
	
	if (( w > 0.0) && (texture(txt, uv).a < 0.2)) {
		color = mix(BORDERNOISE_starting_colour, BORDERNOISE_ending_colour, tanh(3.0*w));
	}
}

void fragment() {
	vec4 color = texture(TEXTURE, UV);
	vec2 size = vec2(textureSize(TEXTURE, 0));
	vec2 uv = UV;
	vec2 screen_uv = SCREEN_UV;

	if(MATRIX_active) matrix(uv, TEXTURE, size, TEXTURE_PIXEL_SIZE, color);
	if(COLORSWAP_active) colorswap(uv, TEXTURE, size, TEXTURE_PIXEL_SIZE, color);
	if(BORDERNOISE_active) borderNoise(uv, TEXTURE, size, TEXTURE_PIXEL_SIZE, color);


	COLOR=color;
}

void vertex() {
	
}