//ATTENTION:
//  THIS IS SHADE AUTOGENERATED BY
//  THE ADDON SPRITE-SHADER-MIXER
//  ANY MANUAL CHANGES WILL BE REMOVED WHEN THE ADDON
//  UPDATES THIS SHADER.
//  ANYWAY, YOU CAN SAVE THE CURRENT VERSION AS A RESOURCE FILE.
//SHADERS:Shield,Hologram,Pulse,
shader_type canvas_item;

	
//SHIELD
uniform bool SHIELD_active = true;
uniform float SHIELD_ring_radius : hint_range(0.1, 0.5, 0.01) = 0.4;
uniform float SHIELD_thickness_scalar : hint_range(0.0, 1, 0.05) = 0.7;
uniform float SHIELD_oscillation_scalar : hint_range(0.0, 0.25, 0.005) = 0.025;
uniform float SHIELD_speed : hint_range(0.0, 50.0, 0.1) = 2.0;
uniform vec4 SHIELD_main_color : source_color = vec4(0.0,0.5,0.0,1.0);
uniform vec4 SHIELD_lerp_color : source_color = vec4(0.0,1.0,0.0,1.0);
float SHIELD_range_lerp(float value, float min1, float min2, float max1, float max2){
	return min2 + (max2 - min2) * ((value - min1) / (max1 - min1));
}
void shield(in vec2 uv, in sampler2D sampler, vec2 size, vec2 pixelSize, inout vec4 color){
	// Calculate the distance between the current pixel and the center of the unit
	float dist = distance(uv, vec2(0.5, 0.5));

	// Add a slight oscillation to the size of the ring
	float o = cos(TIME * SHIELD_speed) - sin(TIME*SHIELD_speed)*dist*SHIELD_speed;
	float ring_size = SHIELD_ring_radius + o * SHIELD_oscillation_scalar;
	
	// Solve for ring alpha channel
	float alpha = step(dist, ring_size) * smoothstep(ring_size * (1.0 - SHIELD_thickness_scalar), ring_size, dist);
	
	// Solve w mix amount for optional color lerping
	float w = SHIELD_range_lerp(o, -1.0, 1.0, 1.0, 0.0);
	
	// Output the final color
	if(alpha>0.){
		vec4 newColor = vec4(mix(SHIELD_main_color.rgb, SHIELD_lerp_color.rgb, w), alpha );
		if(color.a > 0.){
			color = color * mix(newColor, color, 2.*color.a);		
		}else{
			color = newColor;
		}
	}
}
uniform bool  HOLOGRAM_active = true;
uniform float HOLOGRAM_mix : hint_range(0, 1, .1) = 0;
uniform int   HOLOGRAM_lines = 100;
uniform vec4  HOLOGRAM_color1 : source_color = vec4(0.0, 0.0, 1.0, 1.0);
uniform vec4  HOLOGRAM_color2 : source_color = vec4(1.0, 0.0, 0.0, 1.0);  
uniform float HOLOGRAM_speed : hint_range(0.0, 2.0, 0.01) = 0.4;
uniform float HOLOGRAM_alpha : hint_range(0.0, 1.0, 0.01) = 0.5; 
uniform float HOLOGRAM_noise_amount : hint_range(0.0, 1.0, 0.01) = 0.05;
uniform float HOLOGRAM_effect_factor : hint_range(0.0, 1.0, 0.01) = 0.4;
void HOLOGRAM_noise(in vec2 uv, inout vec4 color) {
	float a = fract(sin(dot(uv, vec2(12.9898, 78.233) * TIME)) * 438.5453) * 1.9;
	color.rgb = mix(color.rgb, vec3(a), HOLOGRAM_noise_amount);
}
vec4 HOLOGRAM_color_shift(in vec2 uv, in sampler2D image, vec2 shift_vector) {
	return texture(image, uv - shift_vector);
}
void hologram(in vec2 uv, in sampler2D txt, in vec2 size, in vec2 pixelSize, inout vec4 finalColor){
	float lineN = floor((uv.y - TIME*HOLOGRAM_speed) * float(HOLOGRAM_lines));
	float line_grade = abs(sin(lineN*PI/4.0));
	float smooth_line_grade = abs(sin((uv.y - TIME*HOLOGRAM_speed) * float(HOLOGRAM_lines)));
	
	vec4 line_color = mix(HOLOGRAM_color1, HOLOGRAM_color2, line_grade);
	
	// change the "240.0" literal to control line color shifting
	finalColor = mix(HOLOGRAM_color_shift(uv, txt, vec2(1.0, 0.0)*smooth_line_grade/240.0*HOLOGRAM_effect_factor), finalColor, HOLOGRAM_mix);
	
	HOLOGRAM_noise(uv, finalColor);
	
	finalColor.rgb = mix(finalColor.rgb, line_color.rgb, HOLOGRAM_effect_factor);
	finalColor.a = HOLOGRAM_alpha * finalColor.a * line_color.a;
}

uniform bool PULSE_active = true; //activation
uniform vec4 PULSE_shine_color : source_color = vec4(1.0); //Shine color
uniform float PULSE_alpha_limit : hint_range(0.0, 1.0, 0.1) = 0.0; //Alpha color limit to apply the shine, for example, if you won't to apply the shine to semi-transparent pixels
uniform float PULSE_cycle_speed : hint_range(0.0, 100.0, 0.1) = 1.0; //Pulse cycle speed
uniform bool PULSE_full_pulse_cycle = false; //[False = Do the effect and make a pause] [True = Do the effect continuosly]
void pulse(in vec2 uv, in sampler2D tex, in vec2 spriteSize, in vec2 pixelSize, inout vec4 color)
{
	//Check the pixel alpha value
	if (color.a >= PULSE_alpha_limit)
	{
		float cycle = sin(TIME * PULSE_cycle_speed);
		color.rgb = mix(color.rgb, PULSE_shine_color.rgb, (((cycle >= 0.0) || (PULSE_full_pulse_cycle)) ? abs(cycle) : 0.0) * PULSE_shine_color.a);
	}
}

void fragment() {
	vec4 color = texture(TEXTURE, UV);
	vec2 size = vec2(textureSize(TEXTURE, 0));
	vec2 uv = UV;
	vec2 screen_uv = SCREEN_UV;

	if(SHIELD_active) shield(uv, TEXTURE, size, TEXTURE_PIXEL_SIZE, color);
	if(HOLOGRAM_active) hologram(uv, TEXTURE, size, TEXTURE_PIXEL_SIZE, color);
	if(PULSE_active) pulse(uv, TEXTURE, size, TEXTURE_PIXEL_SIZE, color);


	COLOR=color;
}

void vertex() {
	
}
